{"version":3,"file":"browser.mjs","sources":["../../../../../../packages/animations/browser/src/error_helpers.ts","../../../../../../packages/animations/browser/src/render/web_animations/animatable_props_set.ts","../../../../../../packages/animations/browser/src/render/shared.ts","../../../../../../packages/animations/browser/src/render/animation_driver.ts","../../../../../../packages/animations/browser/src/util.ts","../../../../../../packages/animations/browser/src/warning_helpers.ts","../../../../../../packages/animations/browser/src/dsl/animation_transition_expr.ts","../../../../../../packages/animations/browser/src/dsl/animation_ast_builder.ts","../../../../../../packages/animations/browser/src/dsl/animation_timeline_instruction.ts","../../../../../../packages/animations/browser/src/dsl/element_instruction_map.ts","../../../../../../packages/animations/browser/src/dsl/animation_timeline_builder.ts","../../../../../../packages/animations/browser/src/dsl/animation.ts","../../../../../../packages/animations/browser/src/dsl/style_normalization/animation_style_normalizer.ts","../../../../../../packages/animations/browser/src/dsl/style_normalization/web_animations_style_normalizer.ts","../../../../../../packages/animations/browser/src/dsl/animation_transition_instruction.ts","../../../../../../packages/animations/browser/src/dsl/animation_transition_factory.ts","../../../../../../packages/animations/browser/src/dsl/animation_trigger.ts","../../../../../../packages/animations/browser/src/render/timeline_animation_engine.ts","../../../../../../packages/animations/browser/src/render/transition_animation_engine.ts","../../../../../../packages/animations/browser/src/render/animation_engine_next.ts","../../../../../../packages/animations/browser/src/render/special_cased_styles.ts","../../../../../../packages/animations/browser/src/render/web_animations/web_animations_player.ts","../../../../../../packages/animations/browser/src/render/web_animations/web_animations_driver.ts","../../../../../../packages/animations/browser/src/browser.ts","../../../../../../packages/animations/browser/public_api.ts","../../../../../../packages/animations/browser/index.ts","../../../../../../packages/animations/browser/browser.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\n\nconst LINE_START = '\\n - ';\n\nexport function invalidTimingValue(exp: string|number): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_TIMING_VALUE,\n      ngDevMode && `The provided timing value \"${exp}\" is invalid.`);\n}\n\nexport function negativeStepValue(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.NEGATIVE_STEP_VALUE,\n      ngDevMode && 'Duration values below 0 are not allowed for this animation step.');\n}\n\nexport function negativeDelayValue(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.NEGATIVE_DELAY_VALUE,\n      ngDevMode && 'Delay values below 0 are not allowed for this animation step.');\n}\n\nexport function invalidStyleParams(varName: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_STYLE_PARAMS,\n      ngDevMode &&\n          `Unable to resolve the local animation param ${varName} in the given list of values`);\n}\n\nexport function invalidParamValue(varName: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_PARAM_VALUE,\n      ngDevMode && `Please provide a value for the animation param ${varName}`);\n}\n\nexport function invalidNodeType(nodeType: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_NODE_TYPE,\n      ngDevMode && `Unable to resolve animation metadata node #${nodeType}`);\n}\n\nexport function invalidCssUnitValue(userProvidedProperty: string, value: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_CSS_UNIT_VALUE,\n      ngDevMode && `Please provide a CSS unit value for ${userProvidedProperty}:${value}`);\n}\n\nexport function invalidTrigger(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_TRIGGER,\n      ngDevMode &&\n          'animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\\'@foo\\', [...]))');\n}\n\nexport function invalidDefinition(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_DEFINITION,\n      ngDevMode && 'only state() and transition() definitions can sit inside of a trigger()');\n}\n\nexport function invalidState(metadataName: string, missingSubs: string[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_STATE,\n      ngDevMode &&\n          `state(\"${\n              metadataName}\", ...) must define default values for all the following style substitutions: ${\n              missingSubs.join(', ')}`);\n}\n\nexport function invalidStyleValue(value: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_STYLE_VALUE,\n      ngDevMode && `The provided style string value ${value} is not allowed.`);\n}\n\nexport function invalidProperty(prop: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_PROPERTY,\n      ngDevMode &&\n          `The provided animation property \"${\n              prop}\" is not a supported CSS property for animations`);\n}\n\nexport function invalidParallelAnimation(\n    prop: string, firstStart: number, firstEnd: number, secondStart: number,\n    secondEnd: number): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_PARALLEL_ANIMATION,\n      ngDevMode &&\n          `The CSS property \"${prop}\" that exists between the times of \"${firstStart}ms\" and \"${\n              firstEnd}ms\" is also being animated in a parallel animation between the times of \"${\n              secondStart}ms\" and \"${secondEnd}ms\"`);\n}\n\nexport function invalidKeyframes(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_KEYFRAMES,\n      ngDevMode && `keyframes() must be placed inside of a call to animate()`);\n}\n\nexport function invalidOffset(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_OFFSET,\n      ngDevMode && `Please ensure that all keyframe offsets are between 0 and 1`);\n}\n\nexport function keyframeOffsetsOutOfOrder(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.KEYFRAME_OFFSETS_OUT_OF_ORDER,\n      ngDevMode && `Please ensure that all keyframe offsets are in order`);\n}\n\nexport function keyframesMissingOffsets(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.KEYFRAMES_MISSING_OFFSETS,\n      ngDevMode && `Not all style() steps within the declared keyframes() contain offsets`);\n}\n\nexport function invalidStagger(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_STAGGER,\n      ngDevMode && `stagger() can only be used inside of query()`);\n}\n\nexport function invalidQuery(selector: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_QUERY,\n      ngDevMode &&\n          `\\`query(\"${selector}\")\\` returned zero elements. (Use \\`query(\"${\n              selector}\", { optional: true })\\` if you wish to allow this.)`);\n}\n\nexport function invalidExpression(expr: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_EXPRESSION,\n      ngDevMode && `The provided transition expression \"${expr}\" is not supported`);\n}\n\nexport function invalidTransitionAlias(alias: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.INVALID_TRANSITION_ALIAS,\n      ngDevMode && `The transition alias value \"${alias}\" is not supported`);\n}\n\nexport function validationFailed(errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.VALIDATION_FAILED,\n      ngDevMode && `animation validation failed:\\n${errors.map(err => err.message).join('\\n')}`);\n}\n\nexport function buildingFailed(errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.BUILDING_FAILED,\n      ngDevMode && `animation building failed:\\n${errors.map(err => err.message).join('\\n')}`);\n}\n\nexport function triggerBuildFailed(name: string, errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.TRIGGER_BUILD_FAILED,\n      ngDevMode &&\n          `The animation trigger \"${name}\" has failed to build due to the following errors:\\n - ${\n              errors.map(err => err.message).join('\\n - ')}`);\n}\n\nexport function animationFailed(errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.ANIMATION_FAILED,\n      ngDevMode &&\n          `Unable to animate due to the following errors:${LINE_START}${\n              errors.map(err => err.message).join(LINE_START)}`);\n}\n\nexport function registerFailed(errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.REGISTRATION_FAILED,\n      ngDevMode &&\n          `Unable to build the animation due to the following errors: ${\n              errors.map(err => err.message).join('\\n')}`);\n}\n\nexport function missingOrDestroyedAnimation(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.MISSING_OR_DESTROYED_ANIMATION,\n      ngDevMode && 'The requested animation doesn\\'t exist or has already been destroyed');\n}\n\nexport function createAnimationFailed(errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.CREATE_ANIMATION_FAILED,\n      ngDevMode &&\n          `Unable to create the animation due to the following errors:${\n              errors.map(err => err.message).join('\\n')}`);\n}\n\nexport function missingPlayer(id: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.MISSING_PLAYER,\n      ngDevMode && `Unable to find the timeline player referenced by ${id}`);\n}\n\nexport function missingTrigger(phase: string, name: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.MISSING_TRIGGER,\n      ngDevMode &&\n          `Unable to listen on the animation trigger event \"${\n              phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n}\n\nexport function missingEvent(name: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.MISSING_EVENT,\n      ngDevMode &&\n          `Unable to listen on the animation trigger \"${\n              name}\" because the provided event is undefined!`);\n}\n\nexport function unsupportedTriggerEvent(phase: string, name: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.UNSUPPORTED_TRIGGER_EVENT,\n      ngDevMode &&\n          `The provided animation trigger event \"${phase}\" for the animation trigger \"${\n              name}\" is not supported!`);\n}\n\nexport function unregisteredTrigger(name: string): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.UNREGISTERED_TRIGGER,\n      ngDevMode && `The provided animation trigger \"${name}\" has not been registered!`);\n}\n\nexport function triggerTransitionsFailed(errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.TRIGGER_TRANSITIONS_FAILED,\n      ngDevMode &&\n          `Unable to process animations due to the following failed trigger transitions\\n ${\n              errors.map(err => err.message).join('\\n')}`);\n}\n\nexport function triggerParsingFailed(name: string, errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.TRIGGER_PARSING_FAILED,\n      ngDevMode &&\n          `Animation parsing for the ${name} trigger have failed:${LINE_START}${\n              errors.map(err => err.message).join(LINE_START)}`);\n}\n\nexport function transitionFailed(name: string, errors: Error[]): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.TRANSITION_FAILED,\n      ngDevMode && `@${name} has failed due to:\\n ${errors.map(err => err.message).join('\\n- ')}`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Set of all animatable CSS properties\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties\n */\nexport const ANIMATABLE_PROP_SET = new Set([\n  '-moz-outline-radius',\n  '-moz-outline-radius-bottomleft',\n  '-moz-outline-radius-bottomright',\n  '-moz-outline-radius-topleft',\n  '-moz-outline-radius-topright',\n  '-ms-grid-columns',\n  '-ms-grid-rows',\n  '-webkit-line-clamp',\n  '-webkit-text-fill-color',\n  '-webkit-text-stroke',\n  '-webkit-text-stroke-color',\n  'accent-color',\n  'all',\n  'backdrop-filter',\n  'background',\n  'background-color',\n  'background-position',\n  'background-size',\n  'block-size',\n  'border',\n  'border-block-end',\n  'border-block-end-color',\n  'border-block-end-width',\n  'border-block-start',\n  'border-block-start-color',\n  'border-block-start-width',\n  'border-bottom',\n  'border-bottom-color',\n  'border-bottom-left-radius',\n  'border-bottom-right-radius',\n  'border-bottom-width',\n  'border-color',\n  'border-end-end-radius',\n  'border-end-start-radius',\n  'border-image-outset',\n  'border-image-slice',\n  'border-image-width',\n  'border-inline-end',\n  'border-inline-end-color',\n  'border-inline-end-width',\n  'border-inline-start',\n  'border-inline-start-color',\n  'border-inline-start-width',\n  'border-left',\n  'border-left-color',\n  'border-left-width',\n  'border-radius',\n  'border-right',\n  'border-right-color',\n  'border-right-width',\n  'border-start-end-radius',\n  'border-start-start-radius',\n  'border-top',\n  'border-top-color',\n  'border-top-left-radius',\n  'border-top-right-radius',\n  'border-top-width',\n  'border-width',\n  'bottom',\n  'box-shadow',\n  'caret-color',\n  'clip',\n  'clip-path',\n  'color',\n  'column-count',\n  'column-gap',\n  'column-rule',\n  'column-rule-color',\n  'column-rule-width',\n  'column-width',\n  'columns',\n  'filter',\n  'flex',\n  'flex-basis',\n  'flex-grow',\n  'flex-shrink',\n  'font',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-variation-settings',\n  'font-weight',\n  'gap',\n  'grid-column-gap',\n  'grid-gap',\n  'grid-row-gap',\n  'grid-template-columns',\n  'grid-template-rows',\n  'height',\n  'inline-size',\n  'input-security',\n  'inset',\n  'inset-block',\n  'inset-block-end',\n  'inset-block-start',\n  'inset-inline',\n  'inset-inline-end',\n  'inset-inline-start',\n  'left',\n  'letter-spacing',\n  'line-clamp',\n  'line-height',\n  'margin',\n  'margin-block-end',\n  'margin-block-start',\n  'margin-bottom',\n  'margin-inline-end',\n  'margin-inline-start',\n  'margin-left',\n  'margin-right',\n  'margin-top',\n  'mask',\n  'mask-border',\n  'mask-position',\n  'mask-size',\n  'max-block-size',\n  'max-height',\n  'max-inline-size',\n  'max-lines',\n  'max-width',\n  'min-block-size',\n  'min-height',\n  'min-inline-size',\n  'min-width',\n  'object-position',\n  'offset',\n  'offset-anchor',\n  'offset-distance',\n  'offset-path',\n  'offset-position',\n  'offset-rotate',\n  'opacity',\n  'order',\n  'outline',\n  'outline-color',\n  'outline-offset',\n  'outline-width',\n  'padding',\n  'padding-block-end',\n  'padding-block-start',\n  'padding-bottom',\n  'padding-inline-end',\n  'padding-inline-start',\n  'padding-left',\n  'padding-right',\n  'padding-top',\n  'perspective',\n  'perspective-origin',\n  'right',\n  'rotate',\n  'row-gap',\n  'scale',\n  'scroll-margin',\n  'scroll-margin-block',\n  'scroll-margin-block-end',\n  'scroll-margin-block-start',\n  'scroll-margin-bottom',\n  'scroll-margin-inline',\n  'scroll-margin-inline-end',\n  'scroll-margin-inline-start',\n  'scroll-margin-left',\n  'scroll-margin-right',\n  'scroll-margin-top',\n  'scroll-padding',\n  'scroll-padding-block',\n  'scroll-padding-block-end',\n  'scroll-padding-block-start',\n  'scroll-padding-bottom',\n  'scroll-padding-inline',\n  'scroll-padding-inline-end',\n  'scroll-padding-inline-start',\n  'scroll-padding-left',\n  'scroll-padding-right',\n  'scroll-padding-top',\n  'scroll-snap-coordinate',\n  'scroll-snap-destination',\n  'scrollbar-color',\n  'shape-image-threshold',\n  'shape-margin',\n  'shape-outside',\n  'tab-size',\n  'text-decoration',\n  'text-decoration-color',\n  'text-decoration-thickness',\n  'text-emphasis',\n  'text-emphasis-color',\n  'text-indent',\n  'text-shadow',\n  'text-underline-offset',\n  'top',\n  'transform',\n  'transform-origin',\n  'translate',\n  'vertical-align',\n  'visibility',\n  'width',\n  'word-spacing',\n  'z-index',\n  'zoom',\n]);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimationEvent, AnimationPlayer, AUTO_STYLE, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleDataMap} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\nimport {animationFailed} from '../error_helpers';\n\nimport {ANIMATABLE_PROP_SET} from './web_animations/animatable_props_set';\n\n// We don't include ambient node types here since @angular/animations/browser\n// is meant to target the browser so technically it should not depend on node\n// types. `process` is just declared locally here as a result.\ndeclare const process: any;\n\nexport function isBrowser(): boolean {\n  return (typeof window !== 'undefined' && typeof window.document !== 'undefined');\n}\n\nexport function isNode(): boolean {\n  // Checking only for `process` isn't enough to identify whether or not we're in a Node\n  // environment, because Webpack by default will polyfill the `process`. While we can discern\n  // that Webpack polyfilled it by looking at `process.browser`, it's very Webpack-specific and\n  // might not be future-proof. Instead we look at the stringified version of `process` which\n  // is `[object process]` in Node and `[object Object]` when polyfilled.\n  return typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n}\n\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: Array<ɵStyleDataMap>, preStyles: ɵStyleDataMap = new Map(),\n    postStyles: ɵStyleDataMap = new Map()): Array<ɵStyleDataMap> {\n  const errors: Error[] = [];\n  const normalizedKeyframes: Array<ɵStyleDataMap> = [];\n  let previousOffset = -1;\n  let previousKeyframe: ɵStyleDataMap|null = null;\n  keyframes.forEach(kf => {\n    const offset = kf.get('offset') as number;\n    const isSameOffset = offset == previousOffset;\n    const normalizedKeyframe: ɵStyleDataMap = (isSameOffset && previousKeyframe) || new Map();\n    kf.forEach((val, prop) => {\n      let normalizedProp = prop;\n      let normalizedValue = val;\n      if (prop !== 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\n        switch (normalizedValue) {\n          case PRE_STYLE:\n            normalizedValue = preStyles.get(prop)!;\n            break;\n\n          case AUTO_STYLE:\n            normalizedValue = postStyles.get(prop)!;\n            break;\n\n          default:\n            normalizedValue =\n                normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\n            break;\n        }\n      }\n      normalizedKeyframe.set(normalizedProp, normalizedValue);\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    throw animationFailed(errors);\n  }\n\n  return normalizedKeyframes;\n}\n\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent|undefined,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player)));\n      break;\n    case 'done':\n      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player)));\n      break;\n    case 'destroy':\n      player.onDestroy(() => callback(event && copyAnimationEvent(event, 'destroy', player)));\n      break;\n  }\n}\n\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName: string, player: AnimationPlayer): AnimationEvent {\n  const totalTime = player.totalTime;\n  const disabled = (player as any).disabled ? true : false;\n  const event = makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime, disabled);\n  const data = (e as any)['_data'];\n  if (data != null) {\n    (event as any)['_data'] = data;\n  }\n  return event;\n}\n\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = '',\n    totalTime: number = 0, disabled?: boolean): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime, disabled: !!disabled};\n}\n\nexport function getOrSetDefaultValue<T, V>(map: Map<T, V>, key: T, defaultValue: V) {\n  let value = map.get(key);\n  if (!value) {\n    map.set(key, value = defaultValue);\n  }\n  return value;\n}\n\nexport function parseTimelineCommand(command: string): [string, string] {\n  const separatorPos = command.indexOf(':');\n  const id = command.substring(1, separatorPos);\n  const action = command.slice(separatorPos + 1);\n  return [id, action];\n}\n\nlet _contains: (elm1: any, elm2: any) => boolean = (elm1: any, elm2: any) => false;\nlet _query: (element: any, selector: string, multi: boolean) => any[] =\n    (element: any, selector: string, multi: boolean) => {\n      return [];\n    };\nlet _documentElement: unknown|null = null;\n\nexport function getParentElement(element: any): unknown|null {\n  const parent = element.parentNode || element.host;  // consider host to support shadow DOM\n  if (parent === _documentElement) {\n    return null;\n  }\n  return parent;\n}\n\n// Define utility methods for browsers and platform-server(domino) where Element\n// and utility methods exist.\nconst _isNode = isNode();\nif (_isNode || typeof Element !== 'undefined') {\n  if (!isBrowser()) {\n    _contains = (elm1, elm2) => elm1.contains(elm2);\n  } else {\n    // Read the document element in an IIFE that's been marked pure to avoid a top-level property\n    // read that may prevent tree-shaking.\n    _documentElement = /* @__PURE__ */ (() => document.documentElement)();\n    _contains = (elm1, elm2) => {\n      while (elm2) {\n        if (elm2 === elm1) {\n          return true;\n        }\n        elm2 = getParentElement(elm2);\n      }\n      return false;\n    };\n  }\n\n  _query = (element: any, selector: string, multi: boolean): any[] => {\n    if (multi) {\n      return Array.from(element.querySelectorAll(selector));\n    }\n    const elem = element.querySelector(selector);\n    return elem ? [elem] : [];\n  };\n}\n\nfunction containsVendorPrefix(prop: string): boolean {\n  // Webkit is the only real popular vendor prefix nowadays\n  // cc: http://shouldiprefix.com/\n  return prop.substring(1, 6) == 'ebkit';  // webkit or Webkit\n}\n\nlet _CACHED_BODY: {style: any}|null = null;\nlet _IS_WEBKIT = false;\nexport function validateStyleProperty(prop: string): boolean {\n  if (!_CACHED_BODY) {\n    _CACHED_BODY = getBodyNode() || {};\n    _IS_WEBKIT = _CACHED_BODY!.style ? ('WebkitAppearance' in _CACHED_BODY!.style) : false;\n  }\n\n  let result = true;\n  if (_CACHED_BODY!.style && !containsVendorPrefix(prop)) {\n    result = prop in _CACHED_BODY!.style;\n    if (!result && _IS_WEBKIT) {\n      const camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.slice(1);\n      result = camelProp in _CACHED_BODY!.style;\n    }\n  }\n\n  return result;\n}\n\nexport function validateWebAnimatableStyleProperty(prop: string): boolean {\n  return ANIMATABLE_PROP_SET.has(prop);\n}\n\nexport function getBodyNode(): any|null {\n  if (typeof document != 'undefined') {\n    return document.body;\n  }\n  return null;\n}\n\nexport const containsElement = _contains;\nexport const invokeQuery = _query;\n\nexport function hypenatePropsKeys(original: ɵStyleDataMap): ɵStyleDataMap {\n  const newMap: ɵStyleDataMap = new Map();\n  original.forEach((val, prop) => {\n    const newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');\n    newMap.set(newProp, val);\n  });\n  return newMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimationPlayer, NoopAnimationPlayer} from '@angular/animations';\nimport {Injectable} from '@angular/core';\n\nimport {containsElement, getParentElement, invokeQuery, validateStyleProperty} from './shared';\n\n/**\n * @publicApi\n */\n@Injectable()\nexport class NoopAnimationDriver implements AnimationDriver {\n  validateStyleProperty(prop: string): boolean {\n    return validateStyleProperty(prop);\n  }\n\n  matchesElement(_element: any, _selector: string): boolean {\n    // This method is deprecated and no longer in use so we return false.\n    return false;\n  }\n\n  containsElement(elm1: any, elm2: any): boolean {\n    return containsElement(elm1, elm2);\n  }\n\n  getParentElement(element: unknown): unknown {\n    return getParentElement(element);\n  }\n\n  query(element: any, selector: string, multi: boolean): any[] {\n    return invokeQuery(element, selector, multi);\n  }\n\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: Array<Map<string, string|number>>, duration: number, delay: number,\n      easing: string, previousPlayers: any[] = [],\n      scrubberAccessRequested?: boolean): AnimationPlayer {\n    return new NoopAnimationPlayer(duration, delay);\n  }\n}\n\n/**\n * @publicApi\n */\nexport abstract class AnimationDriver {\n  static NOOP: AnimationDriver = (/* @__PURE__ */ new NoopAnimationDriver());\n\n  abstract validateStyleProperty(prop: string): boolean;\n\n  abstract validateAnimatableStyleProperty?: (prop: string) => boolean;\n\n  /**\n   * @deprecated No longer in use. Will be removed.\n   */\n  abstract matchesElement(element: any, selector: string): boolean;\n\n  abstract containsElement(elm1: any, elm2: any): boolean;\n\n  /**\n   * Obtains the parent element, if any. `null` is returned if the element does not have a parent.\n   */\n  abstract getParentElement(element: unknown): unknown;\n\n  abstract query(element: any, selector: string, multi: boolean): any[];\n\n  abstract computeStyle(element: any, prop: string, defaultValue?: string): string;\n\n  abstract animate(\n      element: any, keyframes: Array<Map<string, string|number>>, duration: number, delay: number,\n      easing?: string|null, previousPlayers?: any[], scrubberAccessRequested?: boolean): any;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimateTimings, AnimationMetadata, AnimationMetadataType, AnimationOptions, sequence, ɵStyleData, ɵStyleDataMap} from '@angular/animations';\n\nimport {Ast as AnimationAst, AstVisitor as AnimationAstVisitor} from './dsl/animation_ast';\nimport {AnimationDslVisitor} from './dsl/animation_dsl_visitor';\nimport {invalidNodeType, invalidParamValue, invalidStyleParams, invalidTimingValue, negativeDelayValue, negativeStepValue} from './error_helpers';\nimport {isNode} from './render/shared';\n\nexport const ONE_SECOND = 1000;\n\nexport const SUBSTITUTION_EXPR_START = '{{';\nexport const SUBSTITUTION_EXPR_END = '}}';\nexport const ENTER_CLASSNAME = 'ng-enter';\nexport const LEAVE_CLASSNAME = 'ng-leave';\nexport const NG_TRIGGER_CLASSNAME = 'ng-trigger';\nexport const NG_TRIGGER_SELECTOR = '.ng-trigger';\nexport const NG_ANIMATING_CLASSNAME = 'ng-animating';\nexport const NG_ANIMATING_SELECTOR = '.ng-animating';\n\nexport function resolveTimingValue(value: string|number) {\n  if (typeof value == 'number') return value;\n\n  const matches = value.match(/^(-?[\\.\\d]+)(m?s)/);\n  if (!matches || matches.length < 2) return 0;\n\n  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\n\nfunction _convertTimeValueToMS(value: number, unit: string): number {\n  switch (unit) {\n    case 's':\n      return value * ONE_SECOND;\n    default:  // ms or something else\n      return value;\n  }\n}\n\nexport function resolveTiming(\n    timings: string|number|AnimateTimings, errors: Error[], allowNegativeValues?: boolean) {\n  return timings.hasOwnProperty('duration') ?\n      <AnimateTimings>timings :\n      parseTimeExpression(<string|number>timings, errors, allowNegativeValues);\n}\n\nfunction parseTimeExpression(\n    exp: string|number, errors: Error[], allowNegativeValues?: boolean): AnimateTimings {\n  const regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let duration: number;\n  let delay: number = 0;\n  let easing: string = '';\n  if (typeof exp === 'string') {\n    const matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(invalidTimingValue(exp));\n      return {duration: 0, delay: 0, easing: ''};\n    }\n\n    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n\n    const delayMatch = matches[3];\n    if (delayMatch != null) {\n      delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);\n    }\n\n    const easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = exp;\n  }\n\n  if (!allowNegativeValues) {\n    let containsErrors = false;\n    let startIndex = errors.length;\n    if (duration < 0) {\n      errors.push(negativeStepValue());\n      containsErrors = true;\n    }\n    if (delay < 0) {\n      errors.push(negativeDelayValue());\n      containsErrors = true;\n    }\n    if (containsErrors) {\n      errors.splice(startIndex, 0, invalidTimingValue(exp));\n    }\n  }\n\n  return {duration, delay, easing};\n}\n\nexport function copyObj(\n    obj: {[key: string]: any}, destination: {[key: string]: any} = {}): {[key: string]: any} {\n  Object.keys(obj).forEach(prop => {\n    destination[prop] = obj[prop];\n  });\n  return destination;\n}\n\nexport function convertToMap(obj: ɵStyleData): ɵStyleDataMap {\n  const styleMap: ɵStyleDataMap = new Map();\n  Object.keys(obj).forEach(prop => {\n    const val = obj[prop];\n    styleMap.set(prop, val);\n  });\n  return styleMap;\n}\n\nexport function normalizeKeyframes(keyframes: Array<ɵStyleData>|\n                                   Array<ɵStyleDataMap>): Array<ɵStyleDataMap> {\n  if (!keyframes.length) {\n    return [];\n  }\n  if (keyframes[0] instanceof Map) {\n    return keyframes as Array<ɵStyleDataMap>;\n  }\n  return keyframes.map(kf => convertToMap(kf as ɵStyleData));\n}\n\nexport function normalizeStyles(styles: ɵStyleDataMap|Array<ɵStyleDataMap>): ɵStyleDataMap {\n  const normalizedStyles: ɵStyleDataMap = new Map();\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, normalizedStyles));\n  } else {\n    copyStyles(styles, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n\nexport function copyStyles(\n    styles: ɵStyleDataMap, destination: ɵStyleDataMap = new Map(),\n    backfill?: ɵStyleDataMap): ɵStyleDataMap {\n  if (backfill) {\n    for (let [prop, val] of backfill) {\n      destination.set(prop, val);\n    }\n  }\n  for (let [prop, val] of styles) {\n    destination.set(prop, val);\n  }\n  return destination;\n}\n\nfunction getStyleAttributeString(element: any, key: string, value: string) {\n  // Return the key-value pair string to be added to the style attribute for the\n  // given CSS style key.\n  if (value) {\n    return key + ':' + value + ';';\n  } else {\n    return '';\n  }\n}\n\nfunction writeStyleAttribute(element: any) {\n  // Read the style property of the element and manually reflect it to the\n  // style attribute. This is needed because Domino on platform-server doesn't\n  // understand the full set of allowed CSS properties and doesn't reflect some\n  // of them automatically.\n  let styleAttrValue = '';\n  for (let i = 0; i < element.style.length; i++) {\n    const key = element.style.item(i);\n    styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));\n  }\n  for (const key in element.style) {\n    // Skip internal Domino properties that don't need to be reflected.\n    if (!element.style.hasOwnProperty(key) || key.startsWith('_')) {\n      continue;\n    }\n    const dashKey = camelCaseToDashCase(key);\n    styleAttrValue += getStyleAttributeString(element, dashKey, element.style[key]);\n  }\n  element.setAttribute('style', styleAttrValue);\n}\n\nexport function setStyles(element: any, styles: ɵStyleDataMap, formerStyles?: ɵStyleDataMap) {\n  if (element['style']) {\n    styles.forEach((val, prop) => {\n      const camelProp = dashCaseToCamelCase(prop);\n      if (formerStyles && !formerStyles.has(prop)) {\n        formerStyles.set(prop, element.style[camelProp]);\n      }\n      element.style[camelProp] = val;\n    });\n    // On the server set the 'style' attribute since it's not automatically reflected.\n    if (isNode()) {\n      writeStyleAttribute(element);\n    }\n  }\n}\n\nexport function eraseStyles(element: any, styles: ɵStyleDataMap) {\n  if (element['style']) {\n    styles.forEach((_, prop) => {\n      const camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = '';\n    });\n    // On the server set the 'style' attribute since it's not automatically reflected.\n    if (isNode()) {\n      writeStyleAttribute(element);\n    }\n  }\n}\n\nexport function normalizeAnimationEntry(steps: AnimationMetadata|\n                                        AnimationMetadata[]): AnimationMetadata {\n  if (Array.isArray(steps)) {\n    if (steps.length == 1) return steps[0];\n    return sequence(steps);\n  }\n  return steps as AnimationMetadata;\n}\n\nexport function validateStyleParams(\n    value: string|number|null|undefined, options: AnimationOptions, errors: Error[]) {\n  const params = options.params || {};\n  const matches = extractStyleParams(value);\n  if (matches.length) {\n    matches.forEach(varName => {\n      if (!params.hasOwnProperty(varName)) {\n        errors.push(invalidStyleParams(varName));\n      }\n    });\n  }\n}\n\nconst PARAM_REGEX =\n    new RegExp(`${SUBSTITUTION_EXPR_START}\\\\s*(.+?)\\\\s*${SUBSTITUTION_EXPR_END}`, 'g');\nexport function extractStyleParams(value: string|number|null|undefined): string[] {\n  let params: string[] = [];\n  if (typeof value === 'string') {\n    let match: any;\n    while (match = PARAM_REGEX.exec(value)) {\n      params.push(match[1] as string);\n    }\n    PARAM_REGEX.lastIndex = 0;\n  }\n  return params;\n}\n\nexport function interpolateParams(\n    value: string|number, params: {[name: string]: any}, errors: Error[]): string|number {\n  const original = value.toString();\n  const str = original.replace(PARAM_REGEX, (_, varName) => {\n    let localVal = params[varName];\n    // this means that the value was never overridden by the data passed in by the user\n    if (localVal == null) {\n      errors.push(invalidParamValue(varName));\n      localVal = '';\n    }\n    return localVal.toString();\n  });\n\n  // we do this to assert that numeric values stay as they are\n  return str == original ? value : str;\n}\n\nexport function iteratorToArray(iterator: any): any[] {\n  const arr: any[] = [];\n  let item = iterator.next();\n  while (!item.done) {\n    arr.push(item.value);\n    item = iterator.next();\n  }\n  return arr;\n}\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function camelCaseToDashCase(input: string): string {\n  return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\nexport function allowPreviousPlayerStylesMerge(duration: number, delay: number) {\n  return duration === 0 || delay === 0;\n}\n\nexport function balancePreviousStylesIntoKeyframes(\n    element: any, keyframes: Array<ɵStyleDataMap>, previousStyles: ɵStyleDataMap) {\n  if (previousStyles.size && keyframes.length) {\n    let startingKeyframe = keyframes[0];\n    let missingStyleProps: string[] = [];\n    previousStyles.forEach((val, prop) => {\n      if (!startingKeyframe.has(prop)) {\n        missingStyleProps.push(prop);\n      }\n      startingKeyframe.set(prop, val);\n    });\n\n    if (missingStyleProps.length) {\n      for (let i = 1; i < keyframes.length; i++) {\n        let kf = keyframes[i];\n        missingStyleProps.forEach(prop => kf.set(prop, computeStyle(element, prop)));\n      }\n    }\n  }\n  return keyframes;\n}\n\nexport function visitDslNode(\n    visitor: AnimationDslVisitor, node: AnimationMetadata, context: any): any;\nexport function visitDslNode(\n    visitor: AnimationAstVisitor, node: AnimationAst<AnimationMetadataType>, context: any): any;\nexport function visitDslNode(visitor: any, node: any, context: any): any {\n  switch (node.type) {\n    case AnimationMetadataType.Trigger:\n      return visitor.visitTrigger(node, context);\n    case AnimationMetadataType.State:\n      return visitor.visitState(node, context);\n    case AnimationMetadataType.Transition:\n      return visitor.visitTransition(node, context);\n    case AnimationMetadataType.Sequence:\n      return visitor.visitSequence(node, context);\n    case AnimationMetadataType.Group:\n      return visitor.visitGroup(node, context);\n    case AnimationMetadataType.Animate:\n      return visitor.visitAnimate(node, context);\n    case AnimationMetadataType.Keyframes:\n      return visitor.visitKeyframes(node, context);\n    case AnimationMetadataType.Style:\n      return visitor.visitStyle(node, context);\n    case AnimationMetadataType.Reference:\n      return visitor.visitReference(node, context);\n    case AnimationMetadataType.AnimateChild:\n      return visitor.visitAnimateChild(node, context);\n    case AnimationMetadataType.AnimateRef:\n      return visitor.visitAnimateRef(node, context);\n    case AnimationMetadataType.Query:\n      return visitor.visitQuery(node, context);\n    case AnimationMetadataType.Stagger:\n      return visitor.visitStagger(node, context);\n    default:\n      throw invalidNodeType(node.type);\n  }\n}\n\nexport function computeStyle(element: any, prop: string): string {\n  return (<any>window.getComputedStyle(element))[prop];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\nfunction createListOfWarnings(warnings: string[]): string {\n  const LINE_START = '\\n - ';\n  return `${LINE_START}${warnings.filter(Boolean).map(warning => warning).join(LINE_START)}`;\n}\n\nexport function warnValidation(warnings: string[]): void {\n  NG_DEV_MODE && console.warn(`animation validation warnings:${createListOfWarnings(warnings)}`);\n}\n\nexport function warnTriggerBuild(name: string, warnings: string[]): void {\n  NG_DEV_MODE &&\n      console.warn(`The animation trigger \"${name}\" has built with the following warnings:${\n          createListOfWarnings(warnings)}`);\n}\n\nexport function warnRegister(warnings: string[]): void {\n  NG_DEV_MODE &&\n      console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);\n}\n\nexport function triggerParsingWarnings(name: string, warnings: string[]): void {\n  NG_DEV_MODE &&\n      console.warn(`Animation parsing for the ${name} trigger presents the following warnings:${\n          createListOfWarnings(warnings)}`);\n}\n\nexport function pushUnrecognizedPropertiesWarning(warnings: string[], props: string[]): void {\n  if (props.length) {\n    warnings.push(`The following provided properties are not recognized: ${props.join(', ')}`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {invalidExpression, invalidTransitionAlias} from '../error_helpers';\n\nexport const ANY_STATE = '*';\nexport declare type TransitionMatcherFn =\n    (fromState: any, toState: any, element: any, params: {[key: string]: any}) => boolean;\n\nexport function parseTransitionExpr(\n    transitionValue: string|TransitionMatcherFn, errors: Error[]): TransitionMatcherFn[] {\n  const expressions: TransitionMatcherFn[] = [];\n  if (typeof transitionValue == 'string') {\n    transitionValue.split(/\\s*,\\s*/).forEach(\n        str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push(<TransitionMatcherFn>transitionValue);\n  }\n  return expressions;\n}\n\nfunction parseInnerTransitionStr(\n    eventStr: string, expressions: TransitionMatcherFn[], errors: Error[]) {\n  if (eventStr[0] == ':') {\n    const result = parseAnimationAlias(eventStr, errors);\n    if (typeof result == 'function') {\n      expressions.push(result);\n      return;\n    }\n    eventStr = result;\n  }\n\n  const match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(invalidExpression(eventStr));\n    return expressions;\n  }\n\n  const fromState = match[1];\n  const separator = match[2];\n  const toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n\n  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n}\n\nfunction parseAnimationAlias(alias: string, errors: Error[]): string|TransitionMatcherFn {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    case ':increment':\n      return (fromState: any, toState: any): boolean => parseFloat(toState) > parseFloat(fromState);\n    case ':decrement':\n      return (fromState: any, toState: any): boolean => parseFloat(toState) < parseFloat(fromState);\n    default:\n      errors.push(invalidTransitionAlias(alias));\n      return '* => *';\n  }\n}\n\n// DO NOT REFACTOR ... keep the follow set instantiations\n// with the values intact (closure compiler for some reason\n// removes follow-up lines that add the values outside of\n// the constructor...\nconst TRUE_BOOLEAN_VALUES = new Set<string>(['true', '1']);\nconst FALSE_BOOLEAN_VALUES = new Set<string>(['false', '0']);\n\nfunction makeLambdaFromStates(lhs: string, rhs: string): TransitionMatcherFn {\n  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n\n  return (fromState: any, toState: any): boolean => {\n    let lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    let rhsMatch = rhs == ANY_STATE || rhs == toState;\n\n    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n    }\n    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n    }\n\n    return lhsMatch && rhsMatch;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimateTimings, AnimationAnimateChildMetadata, AnimationAnimateMetadata, AnimationAnimateRefMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationOptions, AnimationQueryMetadata, AnimationQueryOptions, AnimationReferenceMetadata, AnimationSequenceMetadata, AnimationStaggerMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, AnimationTriggerMetadata, AUTO_STYLE, style, ɵStyleDataMap} from '@angular/animations';\n\nimport {invalidDefinition, invalidKeyframes, invalidOffset, invalidParallelAnimation, invalidProperty, invalidStagger, invalidState, invalidStyleValue, invalidTrigger, keyframeOffsetsOutOfOrder, keyframesMissingOffsets} from '../error_helpers';\nimport {AnimationDriver} from '../render/animation_driver';\nimport {getOrSetDefaultValue} from '../render/shared';\nimport {convertToMap, copyObj, extractStyleParams, iteratorToArray, NG_ANIMATING_SELECTOR, NG_TRIGGER_SELECTOR, normalizeAnimationEntry, resolveTiming, SUBSTITUTION_EXPR_START, validateStyleParams, visitDslNode} from '../util';\nimport {pushUnrecognizedPropertiesWarning} from '../warning_helpers';\n\nimport {AnimateAst, AnimateChildAst, AnimateRefAst, Ast, DynamicTimingAst, GroupAst, KeyframesAst, QueryAst, ReferenceAst, SequenceAst, StaggerAst, StateAst, StyleAst, TimingAst, TransitionAst, TriggerAst} from './animation_ast';\nimport {AnimationDslVisitor} from './animation_dsl_visitor';\nimport {parseTransitionExpr} from './animation_transition_expr';\n\nconst SELF_TOKEN = ':self';\nconst SELF_TOKEN_REGEX = new RegExp(`\\s*${SELF_TOKEN}\\s*,?`, 'g');\n\n/*\n * [Validation]\n * The visitor code below will traverse the animation AST generated by the animation verb functions\n * (the output is a tree of objects) and attempt to perform a series of validations on the data. The\n * following corner-cases will be validated:\n *\n * 1. Overlap of animations\n * Given that a CSS property cannot be animated in more than one place at the same time, it's\n * important that this behavior is detected and validated. The way in which this occurs is that\n * each time a style property is examined, a string-map containing the property will be updated with\n * the start and end times for when the property is used within an animation step.\n *\n * If there are two or more parallel animations that are currently running (these are invoked by the\n * group()) on the same element then the validator will throw an error. Since the start/end timing\n * values are collected for each property then if the current animation step is animating the same\n * property and its timing values fall anywhere into the window of time that the property is\n * currently being animated within then this is what causes an error.\n *\n * 2. Timing values\n * The validator will validate to see if a timing value of `duration delay easing` or\n * `durationNumber` is valid or not.\n *\n * (note that upon validation the code below will replace the timing data with an object containing\n * {duration,delay,easing}.\n *\n * 3. Offset Validation\n * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().\n * Offsets within keyframes() are considered valid when:\n *\n *   - No offsets are used at all\n *   - Each style() entry contains an offset value\n *   - Each offset is between 0 and 1\n *   - Each offset is greater to or equal than the previous one\n *\n * Otherwise an error will be thrown.\n */\nexport function buildAnimationAst(\n    driver: AnimationDriver, metadata: AnimationMetadata|AnimationMetadata[], errors: Error[],\n    warnings: string[]): Ast<AnimationMetadataType> {\n  return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);\n}\n\nconst ROOT_SELECTOR = '';\n\nexport class AnimationAstBuilderVisitor implements AnimationDslVisitor {\n  constructor(private _driver: AnimationDriver) {}\n\n  build(metadata: AnimationMetadata|AnimationMetadata[], errors: Error[], warnings: string[]):\n      Ast<AnimationMetadataType> {\n    const context = new AnimationAstBuilderContext(errors);\n    this._resetContextStyleTimingState(context);\n    const ast =\n        <Ast<AnimationMetadataType>>visitDslNode(this, normalizeAnimationEntry(metadata), context);\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (context.unsupportedCSSPropertiesFound.size) {\n        pushUnrecognizedPropertiesWarning(\n            warnings,\n            [...context.unsupportedCSSPropertiesFound.keys()],\n        );\n      }\n    }\n\n    return ast;\n  }\n\n  private _resetContextStyleTimingState(context: AnimationAstBuilderContext) {\n    context.currentQuerySelector = ROOT_SELECTOR;\n    context.collectedStyles = new Map<string, Map<string, StyleTimeTuple>>();\n    context.collectedStyles.set(ROOT_SELECTOR, new Map());\n    context.currentTime = 0;\n  }\n\n  visitTrigger(metadata: AnimationTriggerMetadata, context: AnimationAstBuilderContext):\n      TriggerAst {\n    let queryCount = context.queryCount = 0;\n    let depCount = context.depCount = 0;\n    const states: StateAst[] = [];\n    const transitions: TransitionAst[] = [];\n    if (metadata.name.charAt(0) == '@') {\n      context.errors.push(invalidTrigger());\n    }\n\n    metadata.definitions.forEach(def => {\n      this._resetContextStyleTimingState(context);\n      if (def.type == AnimationMetadataType.State) {\n        const stateDef = def as AnimationStateMetadata;\n        const name = stateDef.name;\n        name.toString().split(/\\s*,\\s*/).forEach(n => {\n          stateDef.name = n;\n          states.push(this.visitState(stateDef, context));\n        });\n        stateDef.name = name;\n      } else if (def.type == AnimationMetadataType.Transition) {\n        const transition = this.visitTransition(def as AnimationTransitionMetadata, context);\n        queryCount += transition.queryCount;\n        depCount += transition.depCount;\n        transitions.push(transition);\n      } else {\n        context.errors.push(invalidDefinition());\n      }\n    });\n\n    return {\n      type: AnimationMetadataType.Trigger,\n      name: metadata.name,\n      states,\n      transitions,\n      queryCount,\n      depCount,\n      options: null\n    };\n  }\n\n  visitState(metadata: AnimationStateMetadata, context: AnimationAstBuilderContext): StateAst {\n    const styleAst = this.visitStyle(metadata.styles, context);\n    const astParams = (metadata.options && metadata.options.params) || null;\n    if (styleAst.containsDynamicStyles) {\n      const missingSubs = new Set<string>();\n      const params = astParams || {};\n      styleAst.styles.forEach(style => {\n        if (style instanceof Map) {\n          style.forEach(value => {\n            extractStyleParams(value).forEach(sub => {\n              if (!params.hasOwnProperty(sub)) {\n                missingSubs.add(sub);\n              }\n            });\n          });\n        }\n      });\n      if (missingSubs.size) {\n        const missingSubsArr = iteratorToArray(missingSubs.values());\n        context.errors.push(invalidState(metadata.name, missingSubsArr));\n      }\n    }\n\n    return {\n      type: AnimationMetadataType.State,\n      name: metadata.name,\n      style: styleAst,\n      options: astParams ? {params: astParams} : null\n    };\n  }\n\n  visitTransition(metadata: AnimationTransitionMetadata, context: AnimationAstBuilderContext):\n      TransitionAst {\n    context.queryCount = 0;\n    context.depCount = 0;\n    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n    const matchers = parseTransitionExpr(metadata.expr, context.errors);\n\n    return {\n      type: AnimationMetadataType.Transition,\n      matchers,\n      animation,\n      queryCount: context.queryCount,\n      depCount: context.depCount,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitSequence(metadata: AnimationSequenceMetadata, context: AnimationAstBuilderContext):\n      SequenceAst {\n    return {\n      type: AnimationMetadataType.Sequence,\n      steps: metadata.steps.map(s => visitDslNode(this, s, context)),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitGroup(metadata: AnimationGroupMetadata, context: AnimationAstBuilderContext): GroupAst {\n    const currentTime = context.currentTime;\n    let furthestTime = 0;\n    const steps = metadata.steps.map(step => {\n      context.currentTime = currentTime;\n      const innerAst = visitDslNode(this, step, context);\n      furthestTime = Math.max(furthestTime, context.currentTime);\n      return innerAst;\n    });\n\n    context.currentTime = furthestTime;\n    return {\n      type: AnimationMetadataType.Group,\n      steps,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitAnimate(metadata: AnimationAnimateMetadata, context: AnimationAstBuilderContext):\n      AnimateAst {\n    const timingAst = constructTimingAst(metadata.timings, context.errors);\n    context.currentAnimateTimings = timingAst;\n    let styleAst: StyleAst|KeyframesAst;\n    let styleMetadata: AnimationStyleMetadata|AnimationKeyframesSequenceMetadata =\n        metadata.styles ? metadata.styles : style({});\n    if (styleMetadata.type == AnimationMetadataType.Keyframes) {\n      styleAst = this.visitKeyframes(styleMetadata as AnimationKeyframesSequenceMetadata, context);\n    } else {\n      let styleMetadata = metadata.styles as AnimationStyleMetadata;\n      let isEmpty = false;\n      if (!styleMetadata) {\n        isEmpty = true;\n        const newStyleData: {[prop: string]: string|number} = {};\n        if (timingAst.easing) {\n          newStyleData['easing'] = timingAst.easing;\n        }\n        styleMetadata = style(newStyleData);\n      }\n      context.currentTime += timingAst.duration + timingAst.delay;\n      const _styleAst = this.visitStyle(styleMetadata, context);\n      _styleAst.isEmptyStep = isEmpty;\n      styleAst = _styleAst;\n    }\n\n    context.currentAnimateTimings = null;\n    return {\n      type: AnimationMetadataType.Animate,\n      timings: timingAst,\n      style: styleAst,\n      options: null\n    };\n  }\n\n  visitStyle(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext): StyleAst {\n    const ast = this._makeStyleAst(metadata, context);\n    this._validateStyleAst(ast, context);\n    return ast;\n  }\n\n  private _makeStyleAst(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext):\n      StyleAst {\n    const styles: Array<(ɵStyleDataMap | string)> = [];\n    const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];\n\n    for (let styleTuple of metadataStyles) {\n      if (typeof styleTuple === 'string') {\n        if (styleTuple === AUTO_STYLE) {\n          styles.push(styleTuple);\n        } else {\n          context.errors.push(invalidStyleValue(styleTuple));\n        }\n      } else {\n        styles.push(convertToMap(styleTuple));\n      }\n    }\n\n    let containsDynamicStyles = false;\n    let collectedEasing: string|null = null;\n    styles.forEach(styleData => {\n      if (styleData instanceof Map) {\n        if (styleData.has('easing')) {\n          collectedEasing = styleData.get('easing') as string;\n          styleData.delete('easing');\n        }\n        if (!containsDynamicStyles) {\n          for (let value of styleData.values()) {\n            if (value!.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {\n              containsDynamicStyles = true;\n              break;\n            }\n          }\n        }\n      }\n    });\n\n    return {\n      type: AnimationMetadataType.Style,\n      styles,\n      easing: collectedEasing,\n      offset: metadata.offset,\n      containsDynamicStyles,\n      options: null\n    };\n  }\n\n  private _validateStyleAst(ast: StyleAst, context: AnimationAstBuilderContext): void {\n    const timings = context.currentAnimateTimings;\n    let endTime = context.currentTime;\n    let startTime = context.currentTime;\n    if (timings && startTime > 0) {\n      startTime -= timings.duration + timings.delay;\n    }\n\n    ast.styles.forEach(tuple => {\n      if (typeof tuple === 'string') return;\n\n      tuple.forEach((value, prop) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._driver.validateStyleProperty(prop)) {\n            tuple.delete(prop);\n            context.unsupportedCSSPropertiesFound.add(prop);\n            return;\n          }\n        }\n\n        // This is guaranteed to have a defined Map at this querySelector location making it\n        // safe to add the assertion here. It is set as a default empty map in prior methods.\n        const collectedStyles = context.collectedStyles.get(context.currentQuerySelector!)!;\n        const collectedEntry = collectedStyles.get(prop);\n        let updateCollectedStyle = true;\n        if (collectedEntry) {\n          if (startTime != endTime && startTime >= collectedEntry.startTime &&\n              endTime <= collectedEntry.endTime) {\n            context.errors.push(invalidParallelAnimation(\n                prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));\n            updateCollectedStyle = false;\n          }\n\n          // we always choose the smaller start time value since we\n          // want to have a record of the entire animation window where\n          // the style property is being animated in between\n          startTime = collectedEntry.startTime;\n        }\n\n        if (updateCollectedStyle) {\n          collectedStyles.set(prop, {startTime, endTime});\n        }\n\n        if (context.options) {\n          validateStyleParams(value, context.options, context.errors);\n        }\n      });\n    });\n  }\n\n  visitKeyframes(metadata: AnimationKeyframesSequenceMetadata, context: AnimationAstBuilderContext):\n      KeyframesAst {\n    const ast: KeyframesAst = {type: AnimationMetadataType.Keyframes, styles: [], options: null};\n    if (!context.currentAnimateTimings) {\n      context.errors.push(invalidKeyframes());\n      return ast;\n    }\n\n    const MAX_KEYFRAME_OFFSET = 1;\n\n    let totalKeyframesWithOffsets = 0;\n    const offsets: number[] = [];\n    let offsetsOutOfOrder = false;\n    let keyframesOutOfRange = false;\n    let previousOffset: number = 0;\n\n    const keyframes: StyleAst[] = metadata.steps.map(styles => {\n      const style = this._makeStyleAst(styles, context);\n      let offsetVal: number|null =\n          style.offset != null ? style.offset : consumeOffset(style.styles);\n      let offset: number = 0;\n      if (offsetVal != null) {\n        totalKeyframesWithOffsets++;\n        offset = style.offset = offsetVal;\n      }\n      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n      previousOffset = offset;\n      offsets.push(offset);\n      return style;\n    });\n\n    if (keyframesOutOfRange) {\n      context.errors.push(invalidOffset());\n    }\n\n    if (offsetsOutOfOrder) {\n      context.errors.push(keyframeOffsetsOutOfOrder());\n    }\n\n    const length = metadata.steps.length;\n    let generatedOffset = 0;\n    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n      context.errors.push(keyframesMissingOffsets());\n    } else if (totalKeyframesWithOffsets == 0) {\n      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n    }\n\n    const limit = length - 1;\n    const currentTime = context.currentTime;\n    const currentAnimateTimings = context.currentAnimateTimings!;\n    const animateDuration = currentAnimateTimings.duration;\n    keyframes.forEach((kf, i) => {\n      const offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\n      const durationUpToThisFrame = offset * animateDuration;\n      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\n      currentAnimateTimings.duration = durationUpToThisFrame;\n      this._validateStyleAst(kf, context);\n      kf.offset = offset;\n\n      ast.styles.push(kf);\n    });\n\n    return ast;\n  }\n\n  visitReference(metadata: AnimationReferenceMetadata, context: AnimationAstBuilderContext):\n      ReferenceAst {\n    return {\n      type: AnimationMetadataType.Reference,\n      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitAnimateChild(metadata: AnimationAnimateChildMetadata, context: AnimationAstBuilderContext):\n      AnimateChildAst {\n    context.depCount++;\n    return {\n      type: AnimationMetadataType.AnimateChild,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitAnimateRef(metadata: AnimationAnimateRefMetadata, context: AnimationAstBuilderContext):\n      AnimateRefAst {\n    return {\n      type: AnimationMetadataType.AnimateRef,\n      animation: this.visitReference(metadata.animation, context),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitQuery(metadata: AnimationQueryMetadata, context: AnimationAstBuilderContext): QueryAst {\n    const parentSelector = context.currentQuerySelector!;\n    const options = (metadata.options || {}) as AnimationQueryOptions;\n\n    context.queryCount++;\n    context.currentQuery = metadata;\n    const [selector, includeSelf] = normalizeSelector(metadata.selector);\n    context.currentQuerySelector =\n        parentSelector.length ? (parentSelector + ' ' + selector) : selector;\n    getOrSetDefaultValue(context.collectedStyles, context.currentQuerySelector, new Map());\n\n    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n    context.currentQuery = null;\n    context.currentQuerySelector = parentSelector;\n\n    return {\n      type: AnimationMetadataType.Query,\n      selector,\n      limit: options.limit || 0,\n      optional: !!options.optional,\n      includeSelf,\n      animation,\n      originalSelector: metadata.selector,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n\n  visitStagger(metadata: AnimationStaggerMetadata, context: AnimationAstBuilderContext):\n      StaggerAst {\n    if (!context.currentQuery) {\n      context.errors.push(invalidStagger());\n    }\n    const timings = metadata.timings === 'full' ?\n        {duration: 0, delay: 0, easing: 'full'} :\n        resolveTiming(metadata.timings, context.errors, true);\n\n    return {\n      type: AnimationMetadataType.Stagger,\n      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n      timings,\n      options: null\n    };\n  }\n}\n\nfunction normalizeSelector(selector: string): [string, boolean] {\n  const hasAmpersand = selector.split(/\\s*,\\s*/).find(token => token == SELF_TOKEN) ? true : false;\n  if (hasAmpersand) {\n    selector = selector.replace(SELF_TOKEN_REGEX, '');\n  }\n\n  // Note: the :enter and :leave aren't normalized here since those\n  // selectors are filled in at runtime during timeline building\n  selector = selector.replace(/@\\*/g, NG_TRIGGER_SELECTOR)\n                 .replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.slice(1))\n                 .replace(/:animating/g, NG_ANIMATING_SELECTOR);\n\n  return [selector, hasAmpersand];\n}\n\n\nfunction normalizeParams(obj: {[key: string]: any}|any): {[key: string]: any}|null {\n  return obj ? copyObj(obj) : null;\n}\n\nexport type StyleTimeTuple = {\n  startTime: number; endTime: number;\n};\n\nexport class AnimationAstBuilderContext {\n  public queryCount: number = 0;\n  public depCount: number = 0;\n  public currentTransition: AnimationTransitionMetadata|null = null;\n  public currentQuery: AnimationQueryMetadata|null = null;\n  public currentQuerySelector: string|null = null;\n  public currentAnimateTimings: TimingAst|null = null;\n  public currentTime: number = 0;\n  public collectedStyles = new Map<string, Map<string, StyleTimeTuple>>();\n  public options: AnimationOptions|null = null;\n  public unsupportedCSSPropertiesFound: Set<string> = new Set<string>();\n  constructor(public errors: Error[]) {}\n}\n\ntype OffsetStyles = string|ɵStyleDataMap;\n\nfunction consumeOffset(styles: OffsetStyles|Array<OffsetStyles>): number|null {\n  if (typeof styles == 'string') return null;\n\n  let offset: number|null = null;\n\n  if (Array.isArray(styles)) {\n    styles.forEach(styleTuple => {\n      if (styleTuple instanceof Map && styleTuple.has('offset')) {\n        const obj = styleTuple as ɵStyleDataMap;\n        offset = parseFloat(obj.get('offset') as string);\n        obj.delete('offset');\n      }\n    });\n  } else if (styles instanceof Map && styles.has('offset')) {\n    const obj = styles;\n    offset = parseFloat(obj.get('offset') as string);\n    obj.delete('offset');\n  }\n  return offset;\n}\n\nfunction constructTimingAst(value: string|number|AnimateTimings, errors: Error[]) {\n  if (value.hasOwnProperty('duration')) {\n    return value as AnimateTimings;\n  }\n\n  if (typeof value == 'number') {\n    const duration = resolveTiming(value, errors).duration;\n    return makeTimingAst(duration, 0, '');\n  }\n\n  const strValue = value as string;\n  const isDynamic = strValue.split(/\\s+/).some(v => v.charAt(0) == '{' && v.charAt(1) == '{');\n  if (isDynamic) {\n    const ast = makeTimingAst(0, 0, '') as any;\n    ast.dynamic = true;\n    ast.strValue = strValue;\n    return ast as DynamicTimingAst;\n  }\n\n  const timings = resolveTiming(strValue, errors);\n  return makeTimingAst(timings.duration, timings.delay, timings.easing);\n}\n\nfunction normalizeAnimationOptions(options: AnimationOptions|null): AnimationOptions {\n  if (options) {\n    options = copyObj(options);\n    if (options['params']) {\n      options['params'] = normalizeParams(options['params'])!;\n    }\n  } else {\n    options = {};\n  }\n  return options;\n}\n\nfunction makeTimingAst(duration: number, delay: number, easing: string|null): TimingAst {\n  return {duration, delay, easing};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ɵStyleDataMap} from '@angular/animations';\n\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\n\nexport interface AnimationTimelineInstruction extends AnimationEngineInstruction {\n  element: any;\n  keyframes: Array<ɵStyleDataMap>;\n  preStyleProps: string[];\n  postStyleProps: string[];\n  duration: number;\n  delay: number;\n  totalTime: number;\n  easing: string|null;\n  stretchStartingKeyframe?: boolean;\n  subTimeline: boolean;\n}\n\nexport function createTimelineInstruction(\n    element: any, keyframes: Array<ɵStyleDataMap>, preStyleProps: string[],\n    postStyleProps: string[], duration: number, delay: number, easing: string|null = null,\n    subTimeline: boolean = false): AnimationTimelineInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TimelineAnimation,\n    element,\n    keyframes,\n    preStyleProps,\n    postStyleProps,\n    duration,\n    delay,\n    totalTime: duration + delay,\n    easing,\n    subTimeline\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\n\nexport class ElementInstructionMap {\n  private _map = new Map<any, AnimationTimelineInstruction[]>();\n\n  get(element: any): AnimationTimelineInstruction[] {\n    return this._map.get(element) || [];\n  }\n\n  append(element: any, instructions: AnimationTimelineInstruction[]) {\n    let existingInstructions = this._map.get(element);\n    if (!existingInstructions) {\n      this._map.set(element, existingInstructions = []);\n    }\n    existingInstructions.push(...instructions);\n  }\n\n  has(element: any): boolean {\n    return this._map.has(element);\n  }\n\n  clear() {\n    this._map.clear();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimateChildOptions, AnimateTimings, AnimationMetadataType, AnimationOptions, AnimationQueryOptions, AUTO_STYLE, ɵPRE_STYLE as PRE_STYLE, ɵStyleDataMap} from '@angular/animations';\n\nimport {invalidQuery} from '../error_helpers';\nimport {AnimationDriver} from '../render/animation_driver';\nimport {copyStyles, interpolateParams, iteratorToArray, resolveTiming, resolveTimingValue, visitDslNode} from '../util';\n\nimport {AnimateAst, AnimateChildAst, AnimateRefAst, Ast, AstVisitor, DynamicTimingAst, GroupAst, KeyframesAst, QueryAst, ReferenceAst, SequenceAst, StaggerAst, StateAst, StyleAst, TimingAst, TransitionAst, TriggerAst} from './animation_ast';\nimport {AnimationTimelineInstruction, createTimelineInstruction} from './animation_timeline_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\n\nconst ONE_FRAME_IN_MILLISECONDS = 1;\nconst ENTER_TOKEN = ':enter';\nconst ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');\nconst LEAVE_TOKEN = ':leave';\nconst LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\n\n/*\n * The code within this file aims to generate web-animations-compatible keyframes from Angular's\n * animation DSL code.\n *\n * The code below will be converted from:\n *\n * ```\n * sequence([\n *   style({ opacity: 0 }),\n *   animate(1000, style({ opacity: 0 }))\n * ])\n * ```\n *\n * To:\n * ```\n * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]\n * duration = 1000\n * delay = 0\n * easing = ''\n * ```\n *\n * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a\n * combination of AST traversal and merge-sort-like algorithms are used.\n *\n * [AST Traversal]\n * Each of the animation verbs, when executed, will return an string-map object representing what\n * type of action it is (style, animate, group, etc...) and the data associated with it. This means\n * that when functional composition mix of these functions is evaluated (like in the example above)\n * then it will end up producing a tree of objects representing the animation itself.\n *\n * When this animation object tree is processed by the visitor code below it will visit each of the\n * verb statements within the visitor. And during each visit it will build the context of the\n * animation keyframes by interacting with the `TimelineBuilder`.\n *\n * [TimelineBuilder]\n * This class is responsible for tracking the styles and building a series of keyframe objects for a\n * timeline between a start and end time. The builder starts off with an initial timeline and each\n * time the AST comes across a `group()`, `keyframes()` or a combination of the two within a\n * `sequence()` then it will generate a sub timeline for each step as well as a new one after\n * they are complete.\n *\n * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub\n * timeline was created (based on one of the cases above) then the parent timeline will attempt to\n * merge the styles used within the sub timelines into itself (only with group() this will happen).\n * This happens with a merge operation (much like how the merge works in mergeSort) and it will only\n * copy the most recently used styles from the sub timelines into the parent timeline. This ensures\n * that if the styles are used later on in another phase of the animation then they will be the most\n * up-to-date values.\n *\n * [How Missing Styles Are Updated]\n * Each timeline has a `backFill` property which is responsible for filling in new styles into\n * already processed keyframes if a new style shows up later within the animation sequence.\n *\n * ```\n * sequence([\n *   style({ width: 0 }),\n *   animate(1000, style({ width: 100 })),\n *   animate(1000, style({ width: 200 })),\n *   animate(1000, style({ width: 300 }))\n *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn't exist anywhere\n * else\n * ])\n * ```\n *\n * What is happening here is that the `height` value is added later in the sequence, but is missing\n * from all previous animation steps. Therefore when a keyframe is created it would also be missing\n * from all previous keyframes up until where it is first used. For the timeline keyframe generation\n * to properly fill in the style it will place the previous value (the value from the parent\n * timeline) or a default value of `*` into the backFill map. The `copyStyles` method in util.ts\n * handles propagating that backfill map to the styles object.\n *\n * When a sub-timeline is created it will have its own backFill property. This is done so that\n * styles present within the sub-timeline do not accidentally seep into the previous/future timeline\n * keyframes\n *\n * [Validation]\n * The code in this file is not responsible for validation. That functionality happens with within\n * the `AnimationValidatorVisitor` code.\n */\nexport function buildAnimationTimelines(\n    driver: AnimationDriver, rootElement: any, ast: Ast<AnimationMetadataType>,\n    enterClassName: string, leaveClassName: string, startingStyles: ɵStyleDataMap = new Map(),\n    finalStyles: ɵStyleDataMap = new Map(), options: AnimationOptions,\n    subInstructions?: ElementInstructionMap, errors: Error[] = []): AnimationTimelineInstruction[] {\n  return new AnimationTimelineBuilderVisitor().buildKeyframes(\n      driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles,\n      options, subInstructions, errors);\n}\n\nexport class AnimationTimelineBuilderVisitor implements AstVisitor {\n  buildKeyframes(\n      driver: AnimationDriver, rootElement: any, ast: Ast<AnimationMetadataType>,\n      enterClassName: string, leaveClassName: string, startingStyles: ɵStyleDataMap,\n      finalStyles: ɵStyleDataMap, options: AnimationOptions,\n      subInstructions?: ElementInstructionMap,\n      errors: Error[] = []): AnimationTimelineInstruction[] {\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const context = new AnimationTimelineContext(\n        driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\n    context.options = options;\n    const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n    context.currentTimeline.delayNextStep(delay);\n    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\n\n    visitDslNode(this, ast, context);\n\n    // this checks to see if an actual animation happened\n    const timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n\n    // note: we just want to apply the final styles for the rootElement, so we do not\n    //       just apply the styles to the last timeline but the last timeline which\n    //       element is the root one (basically `*`-styles are replaced with the actual\n    //       state style values only for the root element)\n    if (timelines.length && finalStyles.size) {\n      let lastRootTimeline: TimelineBuilder|undefined;\n      for (let i = timelines.length - 1; i >= 0; i--) {\n        const timeline = timelines[i];\n        if (timeline.element === rootElement) {\n          lastRootTimeline = timeline;\n          break;\n        }\n      }\n      if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {\n        lastRootTimeline.setStyles([finalStyles], null, context.errors, options);\n      }\n    }\n    return timelines.length ?\n        timelines.map(timeline => timeline.buildKeyframes()) :\n        [createTimelineInstruction(rootElement, [], [], [], 0, delay, '', false)];\n  }\n\n  visitTrigger(ast: TriggerAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n\n  visitState(ast: StateAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n\n  visitTransition(ast: TransitionAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n\n  visitAnimateChild(ast: AnimateChildAst, context: AnimationTimelineContext): any {\n    const elementInstructions = context.subInstructions.get(context.element);\n    if (elementInstructions) {\n      const innerContext = context.createSubContext(ast.options);\n      const startTime = context.currentTimeline.currentTime;\n      const endTime = this._visitSubInstructions(\n          elementInstructions, innerContext, innerContext.options as AnimateChildOptions);\n      if (startTime != endTime) {\n        // we do this on the upper context because we created a sub context for\n        // the sub child animations\n        context.transformIntoNewTimeline(endTime);\n      }\n    }\n    context.previousNode = ast;\n  }\n\n  visitAnimateRef(ast: AnimateRefAst, context: AnimationTimelineContext): any {\n    const innerContext = context.createSubContext(ast.options);\n    innerContext.transformIntoNewTimeline();\n    this._applyAnimationRefDelays([ast.options, ast.animation.options], context, innerContext);\n    this.visitReference(ast.animation, innerContext);\n    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n    context.previousNode = ast;\n  }\n\n  private _applyAnimationRefDelays(\n      animationsRefsOptions: (AnimationOptions|null)[], context: AnimationTimelineContext,\n      innerContext: AnimationTimelineContext) {\n    for (const animationRefOptions of animationsRefsOptions) {\n      const animationDelay = animationRefOptions?.delay;\n      if (animationDelay) {\n        const animationDelayValue = typeof animationDelay === 'number' ?\n            animationDelay :\n            resolveTimingValue(interpolateParams(\n                animationDelay, animationRefOptions?.params ?? {}, context.errors));\n        innerContext.delayNextStep(animationDelayValue);\n      }\n    }\n  }\n\n  private _visitSubInstructions(\n      instructions: AnimationTimelineInstruction[], context: AnimationTimelineContext,\n      options: AnimateChildOptions): number {\n    const startTime = context.currentTimeline.currentTime;\n    let furthestTime = startTime;\n\n    // this is a special-case for when a user wants to skip a sub\n    // animation from being fired entirely.\n    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;\n    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;\n    if (duration !== 0) {\n      instructions.forEach(instruction => {\n        const instructionTimings =\n            context.appendInstructionToTimeline(instruction, duration, delay);\n        furthestTime =\n            Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n      });\n    }\n\n    return furthestTime;\n  }\n\n  visitReference(ast: ReferenceAst, context: AnimationTimelineContext) {\n    context.updateOptions(ast.options, true);\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n  }\n\n  visitSequence(ast: SequenceAst, context: AnimationTimelineContext) {\n    const subContextCount = context.subContextCount;\n    let ctx = context;\n    const options = ast.options;\n\n    if (options && (options.params || options.delay)) {\n      ctx = context.createSubContext(options);\n      ctx.transformIntoNewTimeline();\n\n      if (options.delay != null) {\n        if (ctx.previousNode.type == AnimationMetadataType.Style) {\n          ctx.currentTimeline.snapshotCurrentStyles();\n          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n\n        const delay = resolveTimingValue(options.delay);\n        ctx.delayNextStep(delay);\n      }\n    }\n\n    if (ast.steps.length) {\n      ast.steps.forEach(s => visitDslNode(this, s, ctx));\n\n      // this is here just in case the inner steps only contain or end with a style() call\n      ctx.currentTimeline.applyStylesToKeyframe();\n\n      // this means that some animation function within the sequence\n      // ended up creating a sub timeline (which means the current\n      // timeline cannot overlap with the contents of the sequence)\n      if (ctx.subContextCount > subContextCount) {\n        ctx.transformIntoNewTimeline();\n      }\n    }\n\n    context.previousNode = ast;\n  }\n\n  visitGroup(ast: GroupAst, context: AnimationTimelineContext) {\n    const innerTimelines: TimelineBuilder[] = [];\n    let furthestTime = context.currentTimeline.currentTime;\n    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\n\n    ast.steps.forEach(s => {\n      const innerContext = context.createSubContext(ast.options);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n\n      visitDslNode(this, s, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n\n    // this operation is run after the AST loop because otherwise\n    // if the parent timeline's collected styles were updated then\n    // it would pass in invalid data into the new-to-be forked items\n    innerTimelines.forEach(\n        timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n\n  private _visitTiming(ast: TimingAst, context: AnimationTimelineContext): AnimateTimings {\n    if ((ast as DynamicTimingAst).dynamic) {\n      const strValue = (ast as DynamicTimingAst).strValue;\n      const timingValue =\n          context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\n      return resolveTiming(timingValue, context.errors);\n    } else {\n      return {duration: ast.duration, delay: ast.delay, easing: ast.easing};\n    }\n  }\n\n  visitAnimate(ast: AnimateAst, context: AnimationTimelineContext) {\n    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\n    const timeline = context.currentTimeline;\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      timeline.snapshotCurrentStyles();\n    }\n\n    const style = ast.style;\n    if (style.type == AnimationMetadataType.Keyframes) {\n      this.visitKeyframes(style, context);\n    } else {\n      context.incrementTime(timings.duration);\n      this.visitStyle(style as StyleAst, context);\n      timeline.applyStylesToKeyframe();\n    }\n\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n\n  visitStyle(ast: StyleAst, context: AnimationTimelineContext) {\n    const timeline = context.currentTimeline;\n    const timings = context.currentAnimateTimings!;\n\n    // this is a special case for when a style() call\n    // directly follows  an animate() call (but not inside of an animate() call)\n    if (!timings && timeline.hasCurrentStyleProperties()) {\n      timeline.forwardFrame();\n    }\n\n    const easing = (timings && timings.easing) || ast.easing;\n    if (ast.isEmptyStep) {\n      timeline.applyEmptyStep(easing);\n    } else {\n      timeline.setStyles(ast.styles, easing, context.errors, context.options);\n    }\n\n    context.previousNode = ast;\n  }\n\n  visitKeyframes(ast: KeyframesAst, context: AnimationTimelineContext) {\n    const currentAnimateTimings = context.currentAnimateTimings!;\n    const startTime = (context.currentTimeline!).duration;\n    const duration = currentAnimateTimings.duration;\n    const innerContext = context.createSubContext();\n    const innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = currentAnimateTimings.easing;\n\n    ast.styles.forEach(step => {\n      const offset: number = step.offset || 0;\n      innerTimeline.forwardTime(offset * duration);\n      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\n      innerTimeline.applyStylesToKeyframe();\n    });\n\n    // this will ensure that the parent timeline gets all the styles from\n    // the child